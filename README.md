# LinuxMonitoring v2.0

Мониторинг и исследование состояния системы в реальном времени.

## Contents

1. [Chapter I](#chapter-i) \
2. [Chapter II](#chapter-ii) \
    2.1. [Bash](#bash) \
    2.2. [Shell](#shell)
3. [Chapter III](#chapter-iii) \
    3.1. [Генератор файлов](#part-1-генератор-файлов)  
    3.2. [Засорение файловой системы](#part-2-засорение-файловой-системы)  
    3.3. [Очистка файловой системы](#part-3-очистка-файловой-системы)  
    3.4. [Генератор логов](#part-4-генератор-логов)  
    3.5. [Мониторинг](#part-5-мониторинг)  
    3.6. [GoAccess](#part-6-goaccess)  
    3.7. [Prometheus и Grafana](#part-7-prometheus-и-grafana)  
    3.8. [Готовый дашборд](#part-8-готовый-дашборд)  
    3.9. [Дополнительно. Свой node_exporter](#part-9-дополнительно-свой-node-exporter)  


## Chapter I
Планета Земля, США, штат Калифорния, наши дни.

Уже в самом начале рабочего дня Вас вызывают к начальству.
Там вам сообщают, что ваш приятель Себ уже 3-ий день не приходит на работу.
Есть риск что его задание не будет завершено в срок.
В связи с этим, вам поручают изучить Линукс-мониторинг, чтобы в случае необходимости подменить вашего нерадивого товарища.

Вы заходите в кабинет Себа, садитесь за его компьютер и сразу открываете его подозрительно недлинный файл с заметками.
Пока вы изучаете ту информацию, что собрал Себ, вы не можете прекратить думать о вкуснейшем обеде, который вы оставили себе в комнате отдыха...

## Chapter II
### **GoAccess**

GoAccess - это анализатор веб-журналов в реальном времени и средство просмотра, которое запускается в терминале или через браузер.
Он предоставляет ценную статистику HTTP, когда требуется визуальный отчет сервера на лету.

### **Prometheus**

Базы данных временных рядов, как следует из их названия, представляют собой системы баз данных,
специально разработанные для обработки данных, связанных со временем.

Большинство систем использует реляционные базы данных, основанные на таблицах.
Такие системы удобны, эффективны и масштабируемы.

Базы данных временных рядов работают по-другому.
Данные по-прежнему хранятся в "коллекциях", но эти коллекции имеют общий знаменатель: они агрегируются с течением времени.
По сути, это означает, что для каждой точки, которую можно сохранить, есть связанная с ней метка времени.

Prometheus — это база данных временных рядов, к которой можно присоединить целую экосистему инструментов, чтобы расширить функционал.
Prometheus создан, чтобы мониторить самые разные системы: серверы, базы данных, отдельные виртуальные машины, да почти что угодно.

### **Grafana**

Grafana — это платформа для визуализации, мониторинга и анализа данных.
Grafana позволяет пользователям создавать *дашборды* с *панелями*, каждая из которых отображает определенные показатели в течение установленного периода времени.
Каждый *дашборд* универсален, поэтому его можно настроить для конкретного проекта.

*Панель* — базовый элемент визуализации выбранных показателей.

*Дашборд* — набор отдельных панелей, размещенных в сетке с набором переменных (например, имя сервера, приложения и т.д.).


## Chapter III
- Написанные Bash-скрипты должны находиться в папке src
- Для каждого задания должна быть создана папка с названием вида: **0x**, где x - номер задания
- Все скрипты должны быть декомпозированы и разбиты на несколько файлов
- Файл с основным сценарием для каждого задания должен называться **main.sh**
- Во всех скриптах должны быть предусмотрены проверки на некорректный ввод (указаны не все параметры, параметры неправильного формата и т.д.)


## Part 1. Генератор файлов

Вечером вы обнаруживаете, что Майк забрал из комнаты отдыха ваш прекрасный сэндвич, который вы специально принесли из дома.
Нельзя это просто так оставлять, вы должны подшутить над ним в ответ.

В качестве подготовки вам нужно освоить работу с файлами в bash-скриптах.

**== Задание ==**

Написать bash-скрипт. Скрипт запускается с 6 параметрами. Пример запуска скрипта:  
**script06.sh /opt/test 4 az 5 az.az 3kb**  

**Параметр 1** - это абсолютный путь.  
**Параметр 2** - это количество вложенных папок.  
**Параметр 3** - это список букв английского алфавита, используемый в названии папок (не более 7 знаков).  
**Параметр 4** - это количество файлов в каждой созданной папке.  
**Параметр 5** - это список букв английского алфавита, используемый в имени файла и расширении (не более 7 знаков для имени, не более 3 знаков для расширения).  
**Параметр 6** - это размер файлов. (в килобайтах, но не более 100).  

Имена папок и файлов должны состоять из только из букв, указанных в параметрах, и использовать каждую из них хотя бы 1 раз.  
Длина этой части имени должна быть от 4 до 9 знаков, плюс дата запуска скрипта в формате DD.MM.YY, отделённая нижним подчёркиванием, например:  
**./aaaz_021121/**, **./aaabcer21_021121**  

При запуске скрипта в указанном в параметре 1 месте, должны быть созданы папки и файлы в них с соответствующими именами и размером.  
Записать лог файл с данными по всем созданным папкам и файлам (полный путь, дата создания, размер для файлов).


## Part 2. Засорение файловой системы

Теперь вы готовы. Пришло время показать Майку, на что способен человек, которого лишили сэндвича.

**== Задание ==**

Написать bash-скрипт. Скрипт запускается с 3 параметрами. Пример запуска скрипта:  
**script07.sh az az.az 3Mb** 

**Параметр 1** диапазон букв английского алфавита, используемый в названии папок.  
**Параметр 2** диапазон букв английского алфавита, используемый в имени файла и расширении.  
**Параметр 3** размер файла. (в Мегабайтах, но не более 100).  

Имена папок и файлов должны состоять из только из букв, указанных в параметрах, и использовать каждую из них хотя бы 1 раз.  
Длина этой части имени должна быть от 5 до 9 знаков, плюс дата запуска скрипта в формате DD.MM.YY, отделённая нижним подчёркиванием, например:  
**./aaaz_021121/**, **./aaabcer21_021121**  

При запуске скрипта, он должен в различных (любых) местах файловой системы создавать папки с файлами.  
Количество вложенных папок - любое. Количество файлов в каждой папке - случайное число (для каждой папки своё).  
Скрипт должен остановить работу, когда в файловой системе (в разделе /) останется 1 Гб свободного места.  
Свободное место в файловой системе определять командой:  
**df -h /**  
Записать лог файл с данными по всем созданным папкам и файлам (полный путь, дата создания, размер для файлов).  
В конце работы скрипта, вывести на экран время его работы.


## Part 3. Очистка файловой системы

Проклятье! Вы запустили скрипт не на том компьютере. Теперь вам срочно нужно написать скрипт, который всё исправит.

**== Задание ==**

Написать bash-скрипт. Скрипт запускается с 1 параметром.
Скрипт должен уметь очистить систему от созданных в **Part 7** папок и файлов 3 способами:

1. По лог файлу
2. По дате создания
3. По маске имени.  

Способ очистки задается при запуске скрипта, как параметр со значением 1, 2 или 3.


## Part 4. Генератор логов

Вы наконец закончили со своими делами и готовы разбираться в мониторинге.
Для начала вам нужно создать логи, которые вы будете анализировать.

**== Задание ==**

Написать bash-скрипт, генерирующий 5 логов **nginx** в *combined* формате.
Каждый лог должен содержать информацию за 1 день.

За день должно быть сгенерировано случайное число записей от 10 до 100.
Для каждой записи должны случайным образом генерироваться:

1. IP (любые)
2. Коды ответа (200, 201, 400, 401, 403, 404, 500, 501, 502, 503)
3. Методы (GET, POST, PUT, PATCH, DELETE)
4. Даты (в рамках заданного дня лога)
5. Агенты (Mozilla, Google Chrome, Opera, Safari, Internet Explorer, Microsoft Edge, Crawler and bot, Library and net tool)

В комментариях в вашем скрипте указать, что означает каждый из использованных кодов ответа.


## Part 5. Мониторинг

Теперь, когда у вас есть файлы для анализа, вы можете приступить к непосредственно мониторингу.

**== Задание ==**

Написать bash-скрипт для разбора логов **nginx** из [Части 4](#part-4-генератор-логов) через **awk**.

Скрипт запускается с 1 параметром, который принимает значение 1, 2, 3 или 4.
В зависимости от значения параметра вывести:

1. Все записи, отсортированные по коду ответа
2. Все уникальные IP, встречающиеся в записях
3. Все запросы с ошибками (код ответа - 4хх или 5хх)
4. Все уникальные IP, которые встречаются среди ошибочных запросов


## Part 6. **GoAccess**

Смотреть на результаты ваших трудов в консоли конечно неплохо, но почему бы не воспользоваться готовым решением, предоставляющим удобный интерфейс?

**== Задание ==**

Написать bash-скрипт с использованием утилиты GoAccess.
С помощью скрипта должно быть возможно получение той же информации, что и в [Части 5](#part-5-мониторинг)

Получить доступ к веб интерфейсу утилиты с вашей локальной машины (мака).


## Part 7. **Prometheus** и **Grafana**

Работа с логами окончена. Теперь пришло время мониторить состояние системы в целом.

**== Задание ==**

##### Установить и настроить утилиты **Prometheus** и **Grafana**
##### Получить доступ к веб интерфейсам утилит с вашей локальной машины (мака)

##### Добавить на дашборд **Grafana** отображение CPU, Memory, место на HDD и IO operation per second на HDD

##### Запустить ваш bash-скрипт из [Части 2](#part-2-засорение-файловой-системы)
##### Посмотреть на нагрузку HDD (место на диске и операции чтения/записи)

##### Установить утилиту **stress** и запустить команду `stress -c 2 -i 1 -m 1 --vm-bytes 32M -t 10s`
##### Посмотреть на нагрузку HDD, Memory и CPU


## Part 8. Готовый дашборд

Собственно, зачем составлять собственный дашборд, если, как говорится, "всё уже украдено до нас"?
Почему бы не взять готовый дашборд, на котором есть все нужные метрики?

**== Задание ==**

##### Установить готовый дашборд *Node Exporter Quickstart and Dashboard* с официального сайта **Grafana Labs**

##### Провести те же тесты, что и в [Части 7](#part-7-prometheus--grafana)

##### Запустить ещё одну виртуальную машину, находящуюся в одной сети с текущей
##### Запустить тест сети с помощью утилиты **iperf3**

##### Посмотреть на нагрузку сетевого интерфейса


## Part 9. Дополнительно. Свой *node_exporter*

Анализировать систему с помощью специальных утилит полезно и удобно, но вам всегда хотелось понять, как же они работают.

**== Задание ==**

Написать bash-скрипт, который собирает информацию по базовым метрикам системы (CPU, Memory, HDD (объем)).
Скрипт должен формировать html страничку по формату **Prometheus**, которую будет отдавать **nginx**.

##### Поменять конфигурационный файл **Prometheus**, чтобы он собирал информацию с созданной вами странички.

##### Провести те же тесты, что и в [Части 7](#part-7-prometheus--grafana)
